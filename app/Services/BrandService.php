<?php

declare(strict_types=1);

namespace App\Services;

use App\Exports\BrandsExport;
use App\Imports\BrandsImport;
use App\Mail\ExportMail;
use App\Models\Brand;
use App\Models\GeneralSetting;
use App\Models\MailSetting;
use App\Models\User;
use App\Traits\CheckPermissionsTrait;
use App\Traits\MailInfo;
use Barryvdh\DomPDF\Facade\Pdf as PDF;
use Illuminate\Contracts\Pagination\LengthAwarePaginator;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Facades\Storage;
use Maatwebsite\Excel\Facades\Excel;
use RuntimeException;
use Symfony\Component\HttpKernel\Exception\ConflictHttpException;

/**
 * Service class for Brand entity lifecycle operations.
 *
 * Centralizes business logic for Brand CRUD, bulk actions, imports/exports,
 * and file handling. Delegates permission checks to CheckPermissionsTrait.
 */
class BrandService extends BaseService
{
    use CheckPermissionsTrait, MailInfo;

    /**
     * Default storage path for brand images when config is missing.
     */
    private const DEFAULT_BRAND_IMAGES_PATH = 'images/brand';

    /**
     * Create a new BrandService instance.
     *
     * @param UploadService $uploadService Handles file uploads for brand images.
     */
    public function __construct(
        private readonly UploadService $uploadService
    ) {}

    /**
     * Retrieve a single brand by instance.
     *
     * Requires brands-index permission. Use for show/display operations.
     *
     * @param Brand $brand The brand instance to retrieve.
     * @return Brand The refreshed brand instance.
     */
    public function getBrand(Brand $brand): Brand
    {
        $this->requirePermission('brands-index');

        return $brand->fresh();
    }

    /**
     * Retrieve brands with optional filters and pagination.
     *
     * Supports filtering by status (active/inactive) and search term.
     * Requires brands-index permission.
     *
     * @param array<string, mixed> $filters Associative array with optional keys: 'status', 'search'.
     * @param int $perPage Number of items per page.
     * @return LengthAwarePaginator<Brand> Paginated brand collection.
     */
    public function getBrands(array $filters = [], int $perPage = 10): LengthAwarePaginator
    {
        $this->requirePermission('brands-index');

        return Brand::query()
            ->when(isset($filters['status']), fn ($q) => 
                $q->where('is_active', $filters['status'] === 'active')
            )
            ->when(!empty($filters['search']), function ($q) use ($filters) {
                $term = "%{$filters['search']}%";
                $q->where(fn ($subQ) => $subQ
                    ->where('name', 'like', $term)
                    ->orWhere('slug', 'like', $term)
                    ->orWhere('short_description', 'like', $term)
                );
            })
            ->latest()
            ->paginate($perPage);
    }

    /**
     * Create a new brand.
     *
     * Handles image upload when present. Slug is auto-generated by the model.
     * Requires brands-create permission.
     *
     * @param array<string, mixed> $data Validated brand attributes including optional 'image' UploadedFile.
     * @return Brand The created brand instance.
     */
    public function createBrand(array $data): Brand
    {
        $this->requirePermission('brands-create');

        return DB::transaction(function () use ($data) {
            if (isset($data['image']) && $data['image'] instanceof UploadedFile) {
                $data = $this->handleImageUpload($data);
            }

            return Brand::create($data);
        });
    }

    /**
     * Update an existing brand.
     *
     * Replaces existing image when a new one is provided. Requires brands-update permission.
     *
     * @param Brand $brand The brand instance to update.
     * @param array<string, mixed> $data Validated brand attributes including optional 'image' UploadedFile.
     * @return Brand The updated brand instance (refreshed).
     */
    public function updateBrand(Brand $brand, array $data): Brand
    {
        $this->requirePermission('brands-update');

        return DB::transaction(function () use ($brand, $data) {
            if (isset($data['image']) && $data['image'] instanceof UploadedFile) {
                if ($brand->image) {
                    $this->uploadService->delete($brand->image);
                }
                $data = $this->handleImageUpload($data);
            }

            $brand->update($data);
            return $brand->fresh();
        });
    }

    /**
     * Soft-delete a brand and remove its image from storage.
     *
     * Fails if the brand has associated products. Requires brands-delete permission.
     *
     * @param Brand $brand The brand instance to delete.
     * @throws ConflictHttpException When brand has associated products (409 Conflict).
     */
    public function deleteBrand(Brand $brand): void
    {
        $this->requirePermission('brands-delete');

        if ($brand->products()->exists()) {
            throw new ConflictHttpException(
                "Cannot delete brand '{$brand->name}' because it has associated products."
            );
        }

        DB::transaction(function () use ($brand) {
            if ($brand->image) {
                $this->uploadService->delete($brand->image);
            }
            $brand->delete();
        });
    }

    /**
     * Bulk soft-delete brands that have no associated products.
     *
     * Skips brands with products. Returns the count of successfully deleted brands.
     * Requires brands-delete permission.
     *
     * @param array<int> $ids Brand IDs to delete.
     * @return int Number of brands successfully deleted.
     */
    public function bulkDeleteBrands(array $ids): int
    {
        $this->requirePermission('brands-delete');

        return DB::transaction(function () use ($ids) {
            // Eager load product count to avoid N+1 and prevent invalid deletes
            $brands = Brand::whereIn('id', $ids)->withCount('products')->get();
            $deletedCount = 0;

            foreach ($brands as $brand) {
                // Skip brands with products
                if ($brand->products_count > 0) {
                    continue;
                }

                if ($brand->image) {
                    $this->uploadService->delete($brand->image);
                }
                
                $brand->delete();
                $deletedCount++;
            }

            return $deletedCount;
        });
    }

    /**
     * Bulk activate brands by ID.
     *
     * Sets is_active to true for all matching brands. Requires brands-update permission.
     *
     * @param array<int> $ids Brand IDs to activate.
     * @return int Number of brands updated.
     */
    public function bulkActivateBrands(array $ids): int
    {
        $this->requirePermission('brands-update');
        return Brand::whereIn('id', $ids)->update(['is_active' => true]);
    }

    /**
     * Bulk deactivate brands by ID.
     *
     * Sets is_active to false for all matching brands. Requires brands-update permission.
     *
     * @param array<int> $ids Brand IDs to deactivate.
     * @return int Number of brands updated.
     */
    public function bulkDeactivateBrands(array $ids): int
    {
        $this->requirePermission('brands-update');
        return Brand::whereIn('id', $ids)->update(['is_active' => false]);
    }

    /**
     * Import brands from an Excel or CSV file.
     *
     * Uses BrandsImport for upsert logic. Requires brands-import permission.
     *
     * @param UploadedFile $file The uploaded import file.
     */
    public function importBrands(UploadedFile $file): void
    {
        $this->requirePermission('brands-import');
        Excel::import(new BrandsImport(), $file);
    }

    /**
     * Export brands to Excel or PDF file.
     *
     * Supports download or email delivery. Requires brands-export permission.
     *
     * @param array<int> $ids Brand IDs to export. Empty array exports all.
     * @param string $format Export format: 'excel' or 'pdf'.
     * @param User|null $user Recipient when method is 'email'. Required for email delivery.
     * @param array<string> $columns Column keys to include in export.
     * @param string $method Delivery method: 'download' or 'email'.
     * @return string Relative storage path of the generated file.
     * @throws RuntimeException When mail settings are not configured and method is 'email'.
     */
    public function exportBrands(array $ids, string $format, ?User $user, array $columns, string $method): string
    {
        $this->requirePermission('brands-export');

        $fileName = 'brands_' . now()->timestamp . '.' . ($format === 'pdf' ? 'pdf' : 'xlsx');
        $relativePath = 'exports/' . $fileName;

        if ($format === 'excel') {
            Excel::store(new BrandsExport($ids, $columns), $relativePath, 'public');
        } else {
            // Retrieve data for PDF
            $brands = Brand::query()
                ->when(!empty($ids), fn ($q) => $q->whereIn('id', $ids))
                ->get();
                
            $pdf = PDF::loadView('exports.brands-pdf', compact('brands', 'columns'));
            Storage::disk('public')->put($relativePath, $pdf->output());
        }

        if ($method === 'email' && $user) {
            $this->sendExportEmail($user, $relativePath, $fileName);
        }

        return $relativePath;
    }

    /**
     * Process image upload and merge path/URL into brand data.
     *
     * @param array<string, mixed> $data Input data containing 'image' as UploadedFile.
     * @return array<string, mixed> Data with 'image' (path) and 'image_url' set.
     */
    private function handleImageUpload(array $data): array
    {
        $path = $this->uploadService->upload(
            $data['image'],
            config('storage.brands.images', self::DEFAULT_BRAND_IMAGES_PATH)
        );

        $data['image'] = $path;
        $data['image_url'] = $this->uploadService->url($path);

        return $data;
    }

    /**
     * Send export completion email to the user.
     *
     * @param User $user Recipient of the export email.
     * @param string $path Relative storage path of the export file.
     * @param string $fileName Display filename for the attachment.
     * @throws RuntimeException When mail settings are not configured.
     */
    private function sendExportEmail(User $user, string $path, string $fileName): void
    {
        $mailSetting = MailSetting::latest()->firstOr(
            fn () => throw new RuntimeException('Mail settings are not configured.')
        );
        $generalSetting = GeneralSetting::latest()->first();

        $this->setMailInfo($mailSetting);
        
        Mail::to($user->email)->send(
            new ExportMail($user, $path, $fileName, 'Brands List', $generalSetting)
        );
    }
}